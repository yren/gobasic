## 谁需要 gc
* 堆: 重点
* 方法区: 有垃圾回收
* 栈: 不需要， 线程私有，随线程消亡，不用考虑gc

## gc 触发条件， 内存不够了
* 新生代内存不够 -> minor gc
* 老年代内存不够 -> full gc

堆 内存划分
新生代 (young gen): Eden 空间, From (survior) 空间, To (survior) 空间 {minor gc}
老年代 (old gen) : {full gc}

默认  新生代 1 : 老年代 2, (1 : 2)
Eden 8: from 1: to 1, (8: 1: 1)

## gc 如何判断对象是否存活

2.1 引用计数算法
引用计数法：给对象添加一个引用计数器，每当有一个地方引用他时，计数器值 + 1, 当引用失效时，计数器 -1. 当计数器为 0 时，就认为对象是不可能再被使用。

优点：快，实现简单。缺点： 对象互相引用很难判断回收。

2.2 可达性分析
通过一系列 GC roots 对象作为起点, 从这些节点开始向下搜索，搜索走过的路径称为引用链 (reference chanin), 当一个对象到 gc roots 没有引用链相连时，证明对象是不可用的。

GC roots 对象包括下面几种:
1. 虚拟机栈中的对象 (方法参数，方法中的局部变量)
2. 方法区中的 静态属性对象 (staic)
3. 方法区中的 常量对象 (final staic)
4. 本地方法栈中的 JNI 的对象

2.3 引用

* 强引用 new
* 软引用 SoftReference<>,  软引用描述一些 有用但是非必要的对象，系统在 OOM 之前会回收 SoftReference.

* 弱引用 WeakReference<>, GC 发生时会被回收。
软引用和弱引用， 可以创建不是很重要的 cache, 当系统内存不足时，缓存中内容可以被释放。

* 虚引用 ， 最弱， 被 GC 时收到一个通知。

## 垃圾回收算法
3.1  复制算法 (copying)
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块
只是这种算法的代价是将内存缩小为了原来的一半。

3.2 标记-清除算法（Mark-Sweep）
3.3 标记-整理算法（Mark-Compact）

## 堆内存分配策略
* 对象优先在Eden分配
如果Eden内存空间不足，就会发生Minor GC

* 大对象直接进入老年代， 虚拟机提供了一个 -XX:PretenureSizeThreshold 参数 ，
大于这个数量直接在老年代分配，缺省为0 ，表示绝不会直接分配在老年代。

* 长期存活的对象将进入老年代
默认15岁，-XX:MaxTenuringThreshold 参数可调整

* 动态对象年龄判定
Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

* 空间分配担保

新生代中有大量的对象存活，survivor空间不够，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。

## Java 内存模型 (java memory model) JMM
java 内存模型定义程序中变量的访问规则，即虚拟机中将变量存储到内存和从内存取出变量的底层细节。这里说的变量，实例字段，静态字段。 不包括局部变量，方法参数，这些是线程私有的，不会被共享。

java 内存模型规定，所有变量都存储在主内存中，每个线程有自己的工作内存。 线程的工作内存保存了线程使用到的主内存变量的拷贝。线程对所有变量的操作都在工作内存中进行，不能直接读写主内存中的变量。不同线程无法访问对方工作内存中的变量。线程间变量值的传递需要通过主内存。

CPU 的缓存一致性，通过 MESI 协议。

java 内存模型定义了 8 种操作和 8 个规则
lock, read, load, use
unlock, assign, store, write

lock: 锁定主内存中的变量，将变量标为一条线程独占
unlock: 解锁主内存变量

read, 作用在主内存，将变量值从主内存传输到工作内存
load, 作用在工作内存，将 read 从主内存获得的变量存放在工作内存的变量副本中。
use, 作用在工作内存，将工作内存中的值传给执行引擎。

assign, 作用在工作内存， 将执行引擎的赋值给工作内存的变量
store, 作用在工作内存变量，把工作内存的变量传送到主内存中
write, 作用在主内存的变量，将 store 操作的变量值传送到主内存。

JMM (java memory model) 是一个规范， JVM 是实现，比如 hotspot vm, volatile 关键字解决指令重排问题。

volatile, 解决2个问题， 1 解决变量对所有线程的可见性， 2 禁止指令重排优化。  

java 内存中的各个区域

Thead stack,  (jvm 虚拟机栈)， 线程私有的，与线程声明周期相同，存放局部变量和对象引用。 可以有 StackOverflowError, OutOfMemoryError

Heap 堆
存放对象实例，几乎所有的对象实例和数组都在堆上分配内存。 会抛出 OutOfMemoryError