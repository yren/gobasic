## 微服务

微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 （例如 Docker）技术，服务可以用不同的编程语言与数据库等。

## 单体应用
LAMP 
apache + tomcat (war) + mysql (spring)

存在的问题
* 部署效率低下 , 单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次，甚至需要 10 分钟以上.
* 团队协作开发成本高, 开发人员多时 (>5), 协同开发成本高。
* 系统高可用性差, 比如功能都在一个 war 包，一个进程，当有一个业务功能内存泄漏。整个服务就不可用了。
* 上线发布慢， 比如 java 应用， 代码膨胀，服务启动的时间就会变长，有些甚至超过 10 分钟以上。 如果有 20 台以上的机器需要部署，相当长的发布时间。

## 服务化
俗的话来讲，服务化就是把传统的单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。

把一些公用的业务功能服务化，比如用户模块从单体应用中拆分出来，独立成一个服务部署，以 RPC 接口的形式对外提供服务。这样，用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合。

微服务得益于以 Docker 为代表的容器化技术的成熟以及 DevOps 文化。

* 服务拆分粒度更细， 小到一个子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分为一个微服务。
* 服务独立部署， 每个微服务都严格遵循独立打包部署的准则，互不影响。
* 服务独立维护， 每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责。
* 服务治理能力要求高，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理。

## 服务拆分

* 纵向拆分，是从业务维度进行拆分, 功能相对比较独立的业务适合单独拆分为一个微服务。
* 横向拆分，是从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。

## 微服务需要解决的问题
* 服务如何定义，接口，HTTP 还是 RPC，服务之间的调用都通过接口描述来约定，约定内容包括接口名、接口参数以及接口返回值
* 服务如何发布和订阅， 注册中心
* 服务如何监控， 我们最关心的是 QPS（调用量), AvgTime（平均耗时）以及 P99, P95.需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。
* 服务如何治理, 服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。熔断，可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回。
* 故障如何定位， 在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位。

微服务架构下，服务调用主要依赖下面几个基本组件：
* 服务描述
RESTful API (swagger), IDL (protobuf)

* 注册中心

提供服务的 service 向注册中心注册。 消费的服务启动时从服务中心订阅自己需要的服务。
注册中心返回 service 列表地址
service 发生变化，(节点增加或删除)，注册中心通知变更给消费者。

* 服务框架
服务通信采用什么协议， 四层 TCP、UDP 协议，还是采用七层 HTTP 协议
数据传输采用什么方式，同步还是异步，是在单连接上传输，还是多路复用。
数据压缩采用什么格式， json, protobuf ...

* 服务监控
指标收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。
数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。
数据展示， dashboard

* 服务追踪

你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。
原理大致：
服务消费者发起调用前，生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者。
服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，并记录一个 span 层数，然后把这两个 requestid 都当作请求参数继续往下传递。
一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的 requestid 串联所有节点，从而达到服务追踪的目的

* 服务治理

单机故障， 自动摘除故障节点
依赖服务不可用， 服务熔断，服务降级



## 服务如何注册和发现
