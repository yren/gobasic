## 微服务

微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 （例如 Docker）技术，服务可以用不同的编程语言与数据库等。

## 单体应用
LAMP 
apache + tomcat (war) + mysql (spring)

存在的问题
* 部署效率低下 , 单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次，甚至需要 10 分钟以上.
* 团队协作开发成本高, 开发人员多时 (>5), 协同开发成本高。
* 系统高可用性差, 比如功能都在一个 war 包，一个进程，当有一个业务功能内存泄漏。整个服务就不可用了。
* 上线发布慢， 比如 java 应用， 代码膨胀，服务启动的时间就会变长，有些甚至超过 10 分钟以上。 如果有 20 台以上的机器需要部署，相当长的发布时间。

## 服务化
服务化就是把传统的单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。

把一些公用的业务功能服务化，比如用户模块从单体应用中拆分出来，独立成一个服务部署，以 RPC 接口的形式对外提供服务。这样，用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合。

微服务得益于以 Docker 为代表的容器化技术的成熟以及 DevOps 文化。

* 服务拆分粒度更细， 小到一个子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分为一个微服务。
* 服务独立部署， 每个微服务都严格遵循独立打包部署的准则，互不影响。
* 服务独立维护， 每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责。
* 服务治理能力要求高，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理。

## 服务拆分

* 纵向拆分，是从业务维度进行拆分, 功能相对比较独立的业务适合单独拆分为一个微服务。
* 横向拆分，是从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。

## 微服务需要解决的问题
* 服务如何定义，接口，HTTP 还是 RPC，服务之间的调用都通过接口描述来约定，约定内容包括接口名、接口参数以及接口返回值
* 服务如何发布和订阅， 注册中心
* 服务如何监控， 我们最关心的是 QPS（调用量), AvgTime（平均耗时）以及 P99, P95.需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。
* 服务如何治理, 服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。熔断，可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回。
* 故障如何定位， 在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位。

微服务架构下，服务调用主要依赖下面几个基本组件：
* 服务描述
RESTful API (swagger), IDL (protobuf)

* 注册中心

提供服务的 service 向注册中心注册。 消费的服务启动时从服务中心订阅自己需要的服务。
注册中心返回 service 列表地址
service 发生变化，(节点增加或删除)，注册中心通知变更给消费者。

* 服务框架
服务通信采用什么协议， 四层 TCP、UDP 协议，还是采用七层 HTTP 协议
数据传输采用什么方式，同步还是异步，是在单连接上传输，还是多路复用。
数据压缩采用什么格式， json, protobuf ...

* 服务监控
指标收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。
数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。
数据展示， dashboard

* 服务追踪

你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。
原理大致：
服务消费者发起调用前，生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者。
服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，并记录一个 span 层数，然后把这两个 requestid 都当作请求参数继续往下传递。
一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的 requestid 串联所有节点，从而达到服务追踪的目的

* 服务治理

单机故障， 自动摘除故障节点
依赖服务不可用， 服务熔断，服务降级



## 服务如何注册和发现
注册中心原理:
主要三种角色: Registry (注册中心)， RPC server, RPC client
* RPC server 提供服务， 启动时，向 Registry 注册自己，并定期发送心跳汇报存活状态
* RPC client 使用服务，启动时，向 Registry 订阅服务，将服务节点列表缓存在本地
* RPC server 变更时， Registry 同步变更， 通知 RPC client 刷新本地服务节点列表
* RPC client , 根据负载均衡算法，选择一个 RPC server 发起调用

### (Registry) 服务中心一般提供的接口
* 服务注册接口
* 服务注销接口
* 心跳汇报接口
* 服务订阅接口

### 服务中心集群部署
* Registry 需要高可用，一般集群部署，并通过分布式一致性协议保持个节点之前的数据一致性。
ZooKeeper (开源注册中心) 的工作原理:
* 每个 server 保存一份数据， client 可以请求任意 server
* zooKeeper 启动时，从实例中选举一个 leader (paxos 协议)
* leader 负责数据处理和更新到其他 server
* 一个更新成功，当且仅当大多数 server 修改成功

这样 zooKeeper 保证了高可用性和数据一致性

### 如何监控微服务

要监控哪些对象
* 接口监控
* 资源监控， 使用的 Redis, memcached ...
* 基础监控， cpu, memory, IO 读写量，网卡带宽 ...

监控指标
* 请求量 , 实时请求量 QPS (query per second),  统计请求量，比如一天的 PV (page view)
* 响应时间，P95, P99, 响应时间，一般 500ms 以上认为是慢请求 （0 - 50）(50 - 100) (100 - 500) (500 以上)
* 错误率，一段时间内调用失败次数，占总次数的比率。 server error 5xx, client error 4xx

监控维度
* 全局维度， 从整体角度监控对象的的请求量、平均耗时以及错误率，全局维度的监控一般是为了让你对监控对象的调用情况有个整体了解。
* Data center 维度，一般为了业务的高可用性，服务通常部署在不止一个机房，因为不同机房地域的不同，同一个监控对象的各种指标可能会相差很大，所以需要深入到机房内部去了解。
* 单机维度， 
* 时间维度, 一天前，一周前，一月前 ..
* 核心维度

监控系统的主要环节
* 数据采集
1. 服务主动上报，代码里加入数据收集逻辑，每次调用完成，上报调用信息
2. 代理收集 ， 代理收集日志
采样率， 高，实时性高，但会影响系统性能，如果需要写入磁盘，会影响磁盘 IO, 设定合适的采样率

* 数据处理
索引数据库， Elastic Search 
时序数据库，  OpenTSDB, 用时序序列的方式存储

* 数据展示

* 曲线图， 一般监控变化趋势，随时间推移监控对象的变化趋势

* 饼状图，一般监控占比分布， 比如不同版本的 app 占比

* 格子图，一般细粒度监控，不同接口机器调用请求量和耗时情况。结果一目了然。


## 如何追踪微服务调用
服务追踪的作用
* 优化系统瓶颈
* 优化链路调用
* 生成网络拓扑
* 透明传输数据

服务追踪系统原理：
核心理念就是调用链：通过一个全局唯一的 ID 将分布在各个服务节点上的同一次请求串联起来，从而还原原有的调用关系，可以追踪系统问题、分析调用数据并统计各种系统指标。

Google 论文 (dapper) 鼻祖

ZipKin
MTrace (美团)

一些概念： traceId、spanId、annonation 等

traceId 是用于串联某一次请求在系统中经过的所有路径，spanId 是用于区分系统不同服务之间调用的先后关系，而 annotation 是用于业务自定义一些自己感兴趣的数据，在上传 traceId 和 spanId 这些基本信息之外，添加一些自己感兴趣的信息。

traceID : requestID
spanID: 0.1.1 (系统不同服务间的先后关系)
annotation: 业务自定义的一些感兴趣的数据

## 微服务治理

* 节点管理
* 负载均衡
随机算法，轮询算法，最少活跃调用算法，一致性 hash , 


* 服务路由
* 服务容错
fail over 失败自动切换
FailBack 失败通知，根据失败信息决定后续策略
FailCache 失败缓存
FailFast 快速失败
